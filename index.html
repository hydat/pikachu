<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pikachu</title>
    <style>
        body {
            font-family: sans-serif;
            background: #1e1f22;
            margin: 0;
            padding: 15% 3% 3% 3%;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            /* THAY ƒê·ªîI T·ª™ min-height: 90vh */
            box-sizing: border-box;
            overflow: hidden;
        }

        /* --- Container ch√≠nh --- */
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 1600px;
            box-sizing: border-box;
        }

        /* --- C·ªôt n√∫t ƒëi·ªÅu khi·ªÉn --- */
        #buttonContainer {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        /* --- Khu v·ª±c b√†n ch∆°i --- */
        #gameArea {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            gap: 20px;
        }

        #boardContainer {
            position: relative;
            display: inline-block;
            justify-content: center;
            align-items: center;
            vertical-align: top;
            touch-action: manipulation;
            -ms-touch-action: manipulation;
        }

        table {
            border-collapse: collapse;
            margin: 0;
            padding: 0;
        }

        td {
            width: 50px;
            height: 50px;
            text-align: center;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            transition: background 0.2s;
        }

        td.empty {
            background: #1e1f22;
            cursor: default;
            border: none;
        }

        td.selected {
            background: #ffef99;
        }

        td.hint {
            background: #90EE90 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                background: #90EE90 !important;
            }

            50% {
                background: #32CD32 !important;
            }

            100% {
                background: #90EE90 !important;
            }
        }

        table img {
            width: 42px;
            height: 42px;
            display: block;
            margin: auto;
        }

        svg#lineLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* --- N√∫t v√† hi·ªÉn th·ªã th√¥ng tin --- */
        button {
            padding: 10px 15px;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            height: fit-content;
            min-width: 120px;
        }

        #refreshBtn {
            background: #4caf50;
        }

        #refreshBtn:hover {
            background: #43a047;
        }

        #hintBtn {
            background: #03a9f4;
        }

        #hintBtn:hover {
            background: #0288d1;
        }

        #hintBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #soundBtn {
            background: #9c27b0;
        }

        #soundBtn:hover {
            background: #7b1fa2;
        }

        #soundBtn.muted {
            background: #616161;
            color: #ccc;
        }

        #levelDisplay {
            background: linear-gradient(45deg, #ffb84d, #ff9f1c);
            color: #fff;
            font-weight: bold;
            padding: 10px 15px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            font-size: 16px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            border-radius: 5px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            height: fit-content;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #levelNumber {
            color: #FFFF00;
            font-size: 18px;
            margin-left: 5px;
        }

        #timerDisplay {
            background: linear-gradient(45deg, #607d8b, #455a64);
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 120px;
            height: fit-content;
            /* TH√äM D√íNG N√ÄY */
        }

        /* --- Responsive: ƒëi·ªán tho·∫°i n·∫±m ngang --- */
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            body {
                padding: 8% 3% 3% 3%;
                /* GI·∫¢M PADDING CHO ƒêI·ªÜN THO·∫†I */
                height: 100vh;
                height: -webkit-fill-available;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                overflow: hidden;
            }

            #container {
                flex-direction: row;
                transform: scale(0.85);
                transform-origin: center center;
                gap: 10px;
            }

            table td {
                width: 36px;
                height: 36px;
            }

            table img {
                width: 30px;
                height: 30px;
            }

            #levelDisplay,
            #refreshBtn,
            #hintBtn,
            #soundBtn,
            #timerDisplay {
                font-size: 14px;
                padding: 6px 10px;
                min-width: 90px;
            }
        }

        /* --- Responsive: ƒëi·ªán tho·∫°i d·ªçc --- */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            body {
                display: flex;
                justify-content: center;
                align-items: center;
                text-align: center;
                height: 100vh;
            }

            #container {
                display: none;
            }

            body::after {
                content: "üì± H√£y xoay ngang ƒëi·ªán tho·∫°i ƒë·ªÉ ch∆°i Pikachu!";
                color: white;
                font-size: 18px;
                font-weight: bold;
                padding: 20px;
            }
        }

        @supports (-webkit-touch-callout: none) {
            body {
                /* Safari mobile */
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        /* ·∫®n address bar tr√™n Safari mobile */
        @media screen and (max-width: 1024px) {
            html {
                height: -webkit-fill-available;
            }

            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
                position: fixed;
                width: 100%;
                overflow: hidden;
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="gameArea">
            <div id="buttonContainer">
                <div id="levelDisplay">Level: <span id="levelNumber">1</span></div>
                <button id="refreshBtn">üîÑ V√°n m·ªõi</button>
                <button id="hintBtn">üí° G·ª£i √Ω</button>
                <button id="soundBtn">üîä √Çm thanh</button>
            </div>
            <div id="boardContainer">
                <table id="board"></table>
                <svg id="lineLayer"></svg>
            </div>
        </div>
    </div>

    <script>
        const ROWS = 9, COLS = 16;
        const icons = [
            "images/2.png",
            "images/6.png",
            "images/8.png",
            "images/12.png",
            "images/15.png",
            "images/17.png",
            "images/18.png",
            "images/20.png",
            "images/24.png",
            "images/25.png",
            "images/28.png",
            "images/30.png",
            "images/33.png",
            "images/36.png",
            "images/38.png",
            "images/40.png",
            "images/42.png",
            "images/45.png",
            "images/49.png",
            "images/52.png",
            "images/55.png",
            "images/56.png",
            "images/59.png",
            "images/61.png",
            "images/64.png",
            "images/68.png",
            "images/71.png",
            "images/72.png",
            "images/76.png",
            "images/78.png",
            "images/80.png",
            "images/86.png",
            "images/89.png",
            "images/92.png",
            "images/95.png",
            "images/97.png",
            "images/99.png",
        ];
        let board = [];
        let selected = [];
        let hintPair = [];
        const MAX_SEGMENTS = 3;
        const MAX_TURNS = Math.max(0, MAX_SEGMENTS - 1);
        let currentLevel = 1;
        let soundEnabled = true;

        const MIN_R = -1, MAX_R = ROWS;
        const MIN_C = -1, MAX_C = COLS;

        let startTime = null;
        let timerInterval = null;

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function initBoard() {
            for (let i = icons.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [icons[i], icons[j]] = [icons[j], icons[i]];
            }
            const total = ROWS * COLS;
            const pairs = [];
            const uniqueCount = Math.floor(total / 4); // m·ªói lo·∫°i xu·∫•t hi·ªán 4 l·∫ßn, kh√≥ h∆°n
            for (let i = 0; i < uniqueCount; i++) {
                const icon = icons[i % icons.length];
                pairs.push(icon, icon, icon, icon); // th√™m 4 m·ªói lo·∫°i
            }
            // c·∫Øt d∆∞
            pairs.length = total;

            // shuffle m·∫°nh h∆°n: Fisher‚ÄìYates 3 l·∫ßn
            for (let t = 0; t < 3; t++) {
                for (let i = pairs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
                }
            }

            board = [];
            let k = 0;
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = pairs[k++];
                }
            }

            // Tr·ªôn l·∫°i th√™m: ho√°n ƒë·ªïi ng·∫´u nhi√™n c√°c √¥ kh√¥ng k·ªÅ nhau
            for (let i = 0; i < total / 2; i++) {
                const r1 = Math.floor(Math.random() * ROWS), c1 = Math.floor(Math.random() * COLS);
                const r2 = Math.floor(Math.random() * ROWS), c2 = Math.floor(Math.random() * COLS);
                if (Math.abs(r1 - r2) + Math.abs(c1 - c2) > 2) {
                    [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                }
            }
        }

        function render() {
            const tb = document.getElementById("board");
            tb.innerHTML = "";
            for (let r = 0; r < ROWS; r++) {
                const tr = document.createElement("tr");
                for (let c = 0; c < COLS; c++) {
                    const td = document.createElement("td");
                    if (board[r][c] == 0) {
                        td.className = "empty";
                    } else {
                        const img = document.createElement("img");
                        img.src = board[r][c];
                        img.style.width = "40px";
                        img.style.height = "40px";
                        img.style.objectFit = "contain";
                        td.appendChild(img);
                    }
                    if (selected.some(p => p.r === r && p.c === c)) td.classList.add("selected");
                    if (hintPair.some(p => p.r === r && p.c === c)) td.classList.add("hint");
                    td.onclick = () => onClick(r, c);
                    tr.appendChild(td);
                }
                tb.appendChild(tr);
            }
        }

        function getCell(r, c) {
            // Trong ph·∫°m vi b·∫£ng th·ª±c
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                return board[r][c];
            }
            // V√πng ·∫£o (ngo√†i b·∫£ng) - lu√¥n tr·∫£ v·ªÅ 0 (tr·ªëng)
            if (r >= MIN_R && r <= MAX_R && c >= MIN_C && c <= MAX_C) {
                return 0;
            }
            // Ngo√†i ph·∫°m vi cho ph√©p
            return null;
        }

        function isEmpty(r, c) { return getCell(r, c) === 0; }

        function clearHorizontal(a, b) {
            if (a.r !== b.r) return false;
            const row = a.r;
            const left = a.c < b.c ? a.c : b.c;
            const right = a.c < b.c ? b.c : a.c;
            for (let c = left + 1; c < right; c++) {
                const val = getCell(row, c);
                if (val === null || val !== 0) return false;
            }
            return true;
        }

        function clearVertical(a, b) {
            if (a.c !== b.c) return false;
            const col = a.c;
            const top = a.r < b.r ? a.r : b.r;
            const bottom = a.r < b.r ? b.r : a.r;
            for (let r = top + 1; r < bottom; r++) {
                const val = getCell(r, col);
                if (val === null || val !== 0) return false;
            }
            return true;
        }

        function findPath(start, end) {
            // BFS nodes: { r, c, dir, turns }
            // dir: 0=up,1=down,2=left,3=right, null = ch∆∞a di chuy·ªÉn
            // We'll allow positions outside b·∫£ng trong v√πng MIN_R..MAX_R, MIN_C..MAX_C (getCell x·ª≠ l√Ω)
            if (start.r === end.r && start.c === end.c) return null;

            // Quick direct checks (faster)
            if (start.r === end.r && clearHorizontal(start, end)) return [start, end];
            if (start.c === end.c && clearVertical(start, end)) return [start, end];

            const dirs = [
                [-1, 0], // up (0)
                [1, 0],  // down (1)
                [0, -1], // left (2)
                [0, 1],  // right (3)
            ];

            // visited map: key = `${r},${c},${dir}` -> minimal turns to reach
            const visited = new Map();
            const parent = new Map(); // parent key -> previous key (for reconstruct)
            const q = [];

            // push start as seed but we don't mark start cell with a direction; we will expand from start in all 4 directions
            for (let d = 0; d < 4; d++) {
                const nr = start.r + dirs[d][0];
                const nc = start.c + dirs[d][1];

                // stop immediately if out of allowed virtual region
                if (nr < MIN_R || nr > MAX_R || nc < MIN_C || nc > MAX_C) continue;

                // can step into if empty or it's the end cell
                const cellVal = getCell(nr, nc);
                if (cellVal === null) continue;
                if (cellVal !== 0 && !(nr === end.r && nc === end.c)) continue;

                const key = `${nr},${nc},${d}`;
                visited.set(key, 0); // 0 turns used so far (first segment started)
                parent.set(key, `${start.r},${start.c},-1`); // parent from start (dir -1)
                q.push({ r: nr, c: nc, dir: d, turns: 0 });
            }

            // BFS
            let foundKey = null;
            while (q.length) {
                const node = q.shift();
                const { r, c, dir, turns } = node;

                // if reached end cell
                if (r === end.r && c === end.c) {
                    foundKey = `${r},${c},${dir}`;
                    break;
                }

                // continue moving along same direction step by step (no new turn)
                // also can try turning to other directions (which increments turns)
                for (let d = 0; d < 4; d++) {
                    const nr = r + dirs[d][0];
                    const nc = c + dirs[d][1];

                    if (nr < MIN_R || nr > MAX_R || nc < MIN_C || nc > MAX_C) continue;
                    const cellVal = getCell(nr, nc);
                    if (cellVal === null) continue;
                    if (cellVal !== 0 && !(nr === end.r && nc === end.c)) continue;

                    // compute new turns count
                    const newTurns = (d === dir) ? turns : turns + 1;
                    if (newTurns > MAX_TURNS) continue;

                    const key = `${nr},${nc},${d}`;
                    if (!visited.has(key) || visited.get(key) > newTurns) {
                        visited.set(key, newTurns);
                        parent.set(key, `${r},${c},${dir}`);
                        q.push({ r: nr, c: nc, dir: d, turns: newTurns });
                    }
                }
            }

            if (!foundKey) return null;

            // reconstruct path from foundKey back to start
            const parts = [];
            let curKey = foundKey;
            while (curKey) {
                const [sr, sc, sdir] = curKey.split(',').map(x => parseInt(x, 10));
                // push cell coordinates
                parts.push({ r: sr, c: sc });
                const p = parent.get(curKey);
                if (!p) break;
                // parent for start was `${start.r},${start.c},-1`
                if (p === `${start.r},${start.c},-1`) {
                    parts.push({ r: start.r, c: start.c });
                    break;
                }
                curKey = p;
            }

            // parts is from end back to start; reverse
            parts.reverse();

            // normalize so first is start and last is end
            // ensure start included (should be)
            if (!(parts.length && parts[0].r === start.r && parts[0].c === start.c)) {
                parts.unshift({ r: start.r, c: start.c });
            }
            if (!(parts.length && parts[parts.length - 1].r === end.r && parts[parts.length - 1].c === end.c)) {
                parts.push({ r: end.r, c: end.c });
            }

            // compress to corner points (compressPath will remove collinear points)
            return compressPath(parts);
        }

        function canConnect(a, b) {
            if (a.r === b.r && a.c === b.c) return null;
            if (board[a.r][a.c] !== board[b.r][b.c]) return null;

            const tmpA = board[a.r][a.c];
            board[a.r][a.c] = 0;
            board[b.r][b.c] = 0;

            const path = findPath(a, b);

            board[a.r][a.c] = tmpA;
            board[b.r][b.c] = tmpA;
            return path;
        }

        function compressPath(path) { // Gi·ªØ start; lo·∫°i b·ªè c√°c ƒëi·ªÉm n·∫±m tr√™n c√πng 1 ƒëo·∫°n th·∫≥ng (gi·ªØ ƒëi·ªÉm cu·ªëi c·ªßa m·ªói ƒëo·∫°n)
            if (!path || path.length === 0) return [];
            const res = [path[0]];
            for (let i = 1; i < path.length; i++) {
                const cur = path[i];
                const prev = res[res.length - 1];
                const prev2 = res.length >= 2 ? res[res.length - 2] : null;

                // n·∫øu prev2, prev v√† cur c√πng h√†ng ho·∫∑c c√πng c·ªôt -> prev n·∫±m gi·ªØa 2 ƒëi·ªÉm th·∫≥ng, thay prev b·∫±ng cur
                if (prev2) {
                    const sameRow = (prev2.r === prev.r && prev.r === cur.r);
                    const sameCol = (prev2.c === prev.c && prev.c === cur.c);
                    if (sameRow || sameCol) {
                        // replace prev b·∫±ng cur ƒë·ªÉ co c·ª•m ƒëo·∫°n th·∫≥ng
                        res[res.length - 1] = cur;
                        continue;
                    }
                }
                res.push(cur);
            }
            return res;
        }

        function drawLine(path) {
            const svg = document.getElementById("lineLayer");
            svg.innerHTML = "";

            if (!path || path.length === 0) return;

            // L·∫•y elements
            const boardEl = document.getElementById("board");
            const boardContainer = document.getElementById("boardContainer");

            // L·∫•y bounding rects
            const boardRect = boardEl.getBoundingClientRect();
            const containerRect = boardContainer.getBoundingClientRect();

            // K√≠ch th∆∞·ªõc cell th·ª±c t·∫ø
            const firstTd = boardEl.querySelector("td");
            const cellW = firstTd ? firstTd.getBoundingClientRect().width : 50;
            const cellH = firstTd ? firstTd.getBoundingClientRect().height : 50;

            // Set SVG size b·∫±ng v·ªõi boardContainer
            svg.setAttribute("width", containerRect.width);
            svg.setAttribute("height", containerRect.height);
            svg.setAttribute("viewBox", `0 0 ${containerRect.width} ${containerRect.height}`);

            // T√≠nh offset t·ª´ boardContainer ƒë·∫øn board
            const offsetX = boardRect.left - containerRect.left;
            const offsetY = boardRect.top - containerRect.top;

            const compressed = compressPath(path);

            // T√≠nh points v·ªõi offset
            const pts = compressed.map(p => {
                const cx = offsetX + (p.c + 0.5) * cellW;
                const cy = offsetY + (p.r + 0.5) * cellH;
                return `${cx},${cy}`;
            }).join(" ");

            // T·∫°o polyline
            const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            polyline.setAttribute("points", pts);
            polyline.setAttribute("stroke", "yellow");
            polyline.setAttribute("stroke-width", "4");
            polyline.setAttribute("fill", "none");
            polyline.setAttribute("stroke-linejoin", "round");
            polyline.setAttribute("stroke-linecap", "round");
            polyline.style.filter = "drop-shadow(0 0 4px rgba(255,200,0,0.6))";

            svg.appendChild(polyline);
        }


        function clearLine() {
            document.getElementById("lineLayer").innerHTML = "";
        }

        function onClick(r, c) {
            if (board[r][c] == 0) return;
            clearHint();
            selected.push({ r, c });
            if (selected.length === 2) {
                const [a, b] = selected;
                const path = canConnect(a, b);
                if (path) {
                    playCorrectSound();
                    drawLine(path);
                    setTimeout(() => {
                        board[a.r][a.c] = 0;
                        board[b.r][b.c] = 0;
                        clearLine();
                        render();
                        if (checkLevelClear()) {
                            playLevelClearSound();
                            nextLevel();
                        }
                    }, 200); // 0.5s hi·ªÉn th·ªã line
                } else {
                    playWrongSound();
                    selected = [];
                    render();
                }
                selected = [];
            }
            render();
        }

        function checkLevelClear() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) return false;
                }
            }
            return true;
        }

        function nextLevel() {
            currentLevel++;
            updateLevel();
            // ·∫®n t·∫•t c·∫£ elements
            const container = document.getElementById("container");
            container.style.display = "none";

            const msg = document.createElement("div");
            msg.textContent = "üéâ Ch√∫c m·ª´ng b·∫°n ƒë√£ qua m√†n ti·∫øp theo ...";
            msg.style.position = "fixed";
            msg.style.top = "40%";
            msg.style.left = "50%";
            msg.style.transform = "translate(-50%, -50%)";
            msg.style.padding = "20px 40px";
            msg.style.fontSize = "24px";
            msg.style.color = "#fff";
            msg.style.background = "rgba(0,0,0,0.7)";
            msg.style.border = "2px solid #ffd700";
            msg.style.borderRadius = "10px";
            msg.style.zIndex = "1000";
            document.body.appendChild(msg);

            setTimeout(() => {
                document.body.removeChild(msg);
                container.style.display = "flex"; // Hi·ªÉn th·ªã l·∫°i container
                initBoard();
                render();
            }, 2000);
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function createAudioContext() {
            return new (window.AudioContext || window.webkitAudioContext)();
        }

        function playCorrectSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh vui v·∫ª cho ƒë√∫ng: C4 -> E4 -> G4
                oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime); // C4
                oscillator.frequency.setValueAtTime(329.63, audioContext.currentTime + 0.1); // E4
                oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime + 0.2); // G4

                oscillator.type = 'triangle';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function playWrongSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh bu·ªìn cho sai: G4 -> D4 -> C4
                oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime); // G4
                oscillator.frequency.setValueAtTime(293.66, audioContext.currentTime + 0.1); // D4
                oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime + 0.2); // C4

                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function playLevelClearSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh chi·∫øn th·∫Øng: C5 -> E5 -> G5 -> C6
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.15); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.3); // G5
                oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.45); // C6

                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.6);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function findHint() {
            const cells = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) {
                        cells.push({ r, c, value: board[r][c] });
                    }
                }
            }

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const a = cells[i];
                    const b = cells[j];
                    if (a.value === b.value && canConnect(a, b)) {
                        return [a, b];
                    }
                }
            }
            return null;
        }

        function showHint() {
            clearHint();
            hintPair = findHint();

            if (hintPair) {
                render();
            } else {
                alert("Kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá! H√£y d√πng n√∫t üîÑ V√°n m·ªõi.");
            }
        }

        function clearHint() {
            hintPair = [];
            const hintCells = document.querySelectorAll("td.hint");
            hintCells.forEach(cell => cell.classList.remove("hint"));
        }

        function newGame() {
            // Reset game state
            selected = [];
            hintPair = [];
            clearHint();
            clearLine();

            // T·∫°o b√†n ch∆°i m·ªõi
            initBoard();
            render();
        }

        function updateLevel() {
            document.getElementById('levelNumber').textContent = currentLevel;
        }

        function changeSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? "üîä √Çm thanh" : "üîá T·∫Øt √¢m thanh";
        }

        document.getElementById('hintBtn').addEventListener('click', showHint);
        document.getElementById('refreshBtn').addEventListener('click', newGame);
        document.getElementById('soundBtn').addEventListener('click', changeSound);

        initBoard();
        render();

        window.addEventListener("orientationchange", () => {
            if (window.orientation === 90 || window.orientation === -90) {
                // N·∫±m ngang
                document.getElementById("container").style.display = "flex";
                document.body.removeAttribute("data-portrait");
            } else {
                // ƒê·ª©ng d·ªçc
                document.getElementById("container").style.display = "none";
                document.body.setAttribute("data-portrait", "true");
            }
        });

        function hideAddressBar() {
            if (window.innerHeight < window.outerHeight) {
                setTimeout(() => {
                    window.scrollTo(0, 1);
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                    }, 100);
                }, 500);
            }
        }

        // G·ªçi khi load v√† khi xoay m√†n h√¨nh
        window.addEventListener('load', hideAddressBar);
        window.addEventListener('orientationchange', () => {
            setTimeout(hideAddressBar, 500);

            if (window.orientation === 90 || window.orientation === -90) {
                document.getElementById("container").style.display = "flex";
                document.body.removeAttribute("data-portrait");
            } else {
                document.getElementById("container").style.display = "none";
                document.body.setAttribute("data-portrait", "true");
            }
        });

        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

    </script>
</body>

</html>