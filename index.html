<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pikachu</title>
    <style>
        body {
            font-family: sans-serif;
            background: #1e1f22;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh;
            /* THAY ƒê·ªîI T·ª™ min-height: 90vh */
            box-sizing: border-box;
            overflow: hidden;
            position: fixed;
            /* TH√äM */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
        }

        /* --- Container ch√≠nh --- */
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            width: 100%;
            max-width: 1600px;
            box-sizing: border-box;
            /* TH√äM C√ÅC D√íNG N√ÄY */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* --- C·ªôt n√∫t ƒëi·ªÅu khi·ªÉn --- */
        #buttonContainer {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        /* --- Khu v·ª±c b√†n ch∆°i --- */
        #gameArea {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            gap: 20px;
        }

        #boardContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: auto;
            height: auto;
        }

        table {
            border-collapse: collapse;
            margin: 0;
            padding: 0;
            table-layout: fixed;
            width: auto;
        }

        td {
            width: 50px;
            height: 50px;
            min-width: 50px;
            max-width: 50px;
            text-align: center;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            transition: background 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            box-sizing: border-box;
            position: relative;
        }

        td.empty {
            background: transparent;
            cursor: default;
            border: none;
            width: 50px;
            height: 50px;
            min-width: 50px;
            max-width: 50px;
        }

        td.selected {
            background: #ffef99;
        }

        td.hint {
            background: #90EE90 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                background: #90EE90 !important;
            }

            50% {
                background: #32CD32 !important;
            }

            100% {
                background: #90EE90 !important;
            }
        }

        table img {
            width: 40px;
            height: 40px;
            display: block;
            margin: auto;
            object-fit: contain;
        }

        svg#lineLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* --- N√∫t v√† hi·ªÉn th·ªã th√¥ng tin --- */
        button {
            padding: 10px 15px;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            height: fit-content;
            min-width: 120px;
        }

        #refreshBtn {
            background: #4caf50;
        }

        #refreshBtn:hover {
            background: #43a047;
        }

        #hintBtn {
            background: #03a9f4;
        }

        #hintBtn:hover {
            background: #0288d1;
        }

        #hintBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #soundBtn {
            background: #9c27b0;
        }

        #soundBtn:hover {
            background: #7b1fa2;
        }

        #soundBtn.muted {
            background: #616161;
            color: #ccc;
        }

        #levelDisplay {
            background: linear-gradient(45deg, #ffb84d, #ff9f1c);
            color: #fff;
            font-weight: bold;
            padding: 10px 15px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            font-size: 16px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            border-radius: 5px;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            height: fit-content;
            /* TH·ªêNG NH·∫§T V·ªöI BUTTON */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #levelNumber {
            color: #FFFF00;
            font-size: 18px;
            margin-left: 5px;
        }

        #timerDisplay {
            background: linear-gradient(45deg, #607d8b, #455a64);
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 120px;
            height: fit-content;
            /* TH√äM D√íNG N√ÄY */
        }

        tr {
            height: 50px;
        }

        .fireworks-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: firework-explode 1s ease-out forwards;
        }

        @keyframes firework-explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }

            50% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .spark {
            position: absolute;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            animation: spark-fly 2s ease-out forwards;
        }

        @keyframes spark-fly {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0);
            }
        }

        /* Tia s√°ng t·ª´ trung t√¢m */
        .firework-ray {
            position: absolute;
            width: 2px;
            height: 30px;
            background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.8), transparent);
            transform-origin: center bottom;
            animation: ray-spread 1.5s ease-out forwards;
        }

        @keyframes ray-spread {
            0% {
                transform: scale(0, 0);
                opacity: 1;
            }

            50% {
                transform: scale(1, 1);
                opacity: 1;
            }

            100% {
                transform: scale(1.5, 1.5);
                opacity: 0;
            }
        }

        /* --- Responsive: ƒëi·ªán tho·∫°i n·∫±m ngang --- */
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            body {
                padding: 0;
                height: 100vh;
                height: 100dvh;
                height: -webkit-fill-available;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                overflow: hidden;
            }

            #container {
                flex-direction: row;
                transform: translate(-50%, -50%) scale(0.85);
                /* K·∫æT H·ª¢P TRANSFORM */
                transform-origin: center center;
                gap: 10px;
                /* ƒê·∫¢M B·∫¢O SAFE AREA */
                padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
            }

            table td {
                width: 36px;
                height: 36px;
            }

            table img {
                width: 30px;
                height: 30px;
            }

            #levelDisplay,
            #refreshBtn,
            #hintBtn,
            #soundBtn,
            #timerDisplay {
                font-size: 14px;
                padding: 6px 10px;
                min-width: 90px;
            }
        }

        /* --- Responsive: ƒëi·ªán tho·∫°i d·ªçc --- */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            body {
                display: flex;
                justify-content: center;
                align-items: center;
                text-align: center;
            }

            #container {
                display: none;
            }

            /* X√ìA message y√™u c·∫ßu xoay */
            body::after {
                content: "üì± H√£y xoay ngang ƒëi·ªán tho·∫°i ƒë·ªÉ ch∆°i Pikachu!";
                color: white;
                font-size: 18px;
                font-weight: bold;
                padding: 20px;
            }
        }

        @supports (-webkit-touch-callout: none) {
            body {
                /* Safari mobile */
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        /* ·∫®n address bar tr√™n Safari mobile */
        @media screen and (max-width: 1024px) {
            html {
                height: -webkit-fill-available;
            }

            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
                position: fixed;
                width: 100%;
                overflow: hidden;
            }
        }

        /* Support cho t·∫•t c·∫£ iPhone models */
        @supports (padding: max(0px)) {
            #container {
                padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
            }
        }

        /* iPhone 8/8 Plus specific */
        @media screen and (max-width: 768px) and (max-height: 736px) {
            #container {
                transform: translate(-50%, -45%);
                /* D·ªäCH L√äN 1 CH√öT */
            }
        }

        /* iPhone X/11/12/13/14 series specific */
        @media screen and (max-width: 430px) and (min-height: 800px) {
            #container {
                transform: translate(-50%, -50%);
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(20px, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="gameArea">
            <div id="buttonContainer">
                <div id="levelDisplay">Level: <span id="levelNumber">1</span></div>
                <button id="refreshBtn">üîÑ V√°n m·ªõi</button>
                <button id="hintBtn">üí° G·ª£i √Ω</button>
                <button id="soundBtn">üîä √Çm thanh</button>
            </div>
            <div id="boardContainer">
                <table id="board"></table>
                <svg id="lineLayer"></svg>
            </div>
        </div>
    </div>

    <script>
        const ROWS = 8, COLS = 14;
        const icons = [
            "images/6.png",
            "images/15.png",
            "images/17.png",
            "images/18.png",
            "images/24.png",
            "images/38.png",
            "images/42.png",
            "images/49.png",
            "images/53.png",
            "images/57.png",
            "images/59.png",
            "images/62.png",
            "images/64.png",
            "images/68.png",
            "images/71.png",
            "images/73.png",
            "images/76.png",
            "images/78.png",
            "images/80.png",
            "images/85.png",
            "images/87.png",
            "images/89.png",
            "images/92.png",
            "images/95.png",
            "images/99.png",
            "images/103.png",
            "images/108.png",
            "images/110.png",
            "images/111.png",
            "images/112.png",
            "images/115.png",
            "images/125.png",
            "images/128.png",
            "images/130.png",
            "images/131.png",
            "images/141.png",
            "images/142.png",
            "images/144.png",
            "images/145.png",
            "images/148.png",
            "images/149.png",
            "images/150.png",
            "images/160.png",
            "images/169.png",
            "images/212.png",
            "images/217.png",
            "images/219.png",
            "images/221.png",
            "images/226.png",
            "images/227.png",
            "images/229.png",
            "images/230.png",
            "images/232.png",
            "images/242.png",
            "images/243.png",
            "images/244.png",
            "images/248.png",
            "images/249.png",
            "images/250.png",
            "images/257.png",
            "images/260.png",
            "images/262.png",
            "images/272.png",
            "images/275.png",
            "images/277.png",
            "images/279.png",
            "images/282.png",
            "images/284.png",
            "images/289.png",
            "images/294.png",
            "images/297.png",
            "images/305.png",
            "images/310.png",
            "images/319.png",
            "images/321.png",
            "images/323.png",
            "images/326.png",
            "images/330.png",
            "images/332.png",
            "images/334.png",
            "images/336.png",
            "images/342.png",
            "images/344.png",
            "images/346.png",
            "images/348.png",
            "images/350.png",
            "images/356.png",
            "images/357.png",
            "images/367.png",
            "images/373.png",
            "images/375.png",
            "images/377.png",
            "images/379.png",
            "images/381.png",
            "images/383.png",
            "images/386.png",
            "images/395.png",
            "images/398.png",
            "images/400.png",
            "images/405.png",
            "images/409.png",
            "images/419.png",
            "images/424.png",
            "images/432.png",
            "images/435.png",
            "images/444.png",
            "images/450.png",
            "images/452.png",
            "images/455.png",
            "images/460.png",
            "images/463.png",
            "images/465.png",
            "images/466.png",
            "images/467.png",
            "images/469.png",
        ];
        let board = [];
        let selected = [];
        let hintPair = [];
        const MAX_SEGMENTS = 3;
        const MAX_TURNS = Math.max(0, MAX_SEGMENTS - 1);
        let currentLevel = 1;
        let soundEnabled = true;

        const MIN_R = -1, MAX_R = ROWS;
        const MIN_C = -1, MAX_C = COLS;

        let startTime = null;
        let timerInterval = null;

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function createFireworks() {
            const container = document.createElement('div');
            container.className = 'fireworks-container';
            document.body.appendChild(container);

            // T·∫°o 30 qu·∫£ ph√°o hoa ·ªü v·ªã tr√≠ ng·∫´u nhi√™n
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createSingleFirework(container);
                }, i * 100); // Delay m·ªói qu·∫£ 100ms
            }

            // X√≥a container sau 5 gi√¢y
            setTimeout(() => {
                if (document.body.contains(container)) {
                    document.body.removeChild(container);
                }
            }, 3000);
        }

        function createSingleFirework(container) {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8', '#ff7675'];
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * (window.innerHeight * 0.6) + window.innerHeight * 0.1; // ·ªû ph·∫ßn tr√™n m√†n h√¨nh

            // T·∫°o t√¢m ph√°o hoa
            const firework = document.createElement('div');
            firework.className = 'firework';
            firework.style.left = x + 'px';
            firework.style.top = y + 'px';
            firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            container.appendChild(firework);

            // T·∫°o c√°c tia l·ª≠a bay ra xung quanh
            for (let i = 0; i < 150; i++) {
                setTimeout(() => {
                    createSpark(container, x, y, colors[Math.floor(Math.random() * colors.length)]);
                }, 100);
            }

            // T·∫°o c√°c tia s√°ng
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createRay(container, x, y, i * 30); // M·ªói tia c√°ch nhau 30 ƒë·ªô
                }, 150);
            }
        }

        function createSpark(container, centerX, centerY, color) {
            const spark = document.createElement('div');
            spark.className = 'spark';
            spark.style.backgroundColor = color;
            spark.style.boxShadow = `0 0 6px ${color}`;

            // V·ªã tr√≠ ban ƒë·∫ßu
            spark.style.left = centerX + 'px';
            spark.style.top = centerY + 'px';

            // H∆∞·ªõng bay ng·∫´u nhi√™n
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 100 + 50;
            const endX = centerX + Math.cos(angle) * distance;
            const endY = centerY + Math.sin(angle) * distance;

            container.appendChild(spark);

            // Animation bay ra
            spark.animate([
                { transform: 'translate(0, 0)', opacity: 1 },
                { transform: `translate(${endX - centerX}px, ${endY - centerY}px)`, opacity: 0 }
            ], {
                duration: 1500,
                easing: 'ease-out'
            });

            // X√≥a sau khi animation xong
            setTimeout(() => {
                if (container.contains(spark)) {
                    container.removeChild(spark);
                }
            }, 1500);
        }

        function createRay(container, centerX, centerY, rotation) {
            const ray = document.createElement('div');
            ray.className = 'firework-ray';
            ray.style.left = centerX + 'px';
            ray.style.top = centerY + 'px';
            ray.style.transform = `rotate(${rotation}deg)`;

            container.appendChild(ray);

            // X√≥a sau 1.5 gi√¢y
            setTimeout(() => {
                if (container.contains(ray)) {
                    container.removeChild(ray);
                }
            }, 1500);
        }

        function initBoard() {
            for (let i = icons.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [icons[i], icons[j]] = [icons[j], icons[i]];
            }
            const total = ROWS * COLS;
            const pairs = [];
            const uniqueCount = Math.floor(total / 4); // m·ªói lo·∫°i xu·∫•t hi·ªán 4 l·∫ßn, kh√≥ h∆°n
            for (let i = 0; i < uniqueCount; i++) {
                const icon = icons[i % icons.length];
                pairs.push(icon, icon, icon, icon); // th√™m 4 m·ªói lo·∫°i
            }
            // c·∫Øt d∆∞
            pairs.length = total;

            // shuffle m·∫°nh h∆°n: Fisher‚ÄìYates 3 l·∫ßn
            for (let t = 0; t < 3; t++) {
                for (let i = pairs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
                }
            }

            board = [];
            let k = 0;
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = pairs[k++];
                }
            }

            // Tr·ªôn l·∫°i th√™m: ho√°n ƒë·ªïi ng·∫´u nhi√™n c√°c √¥ kh√¥ng k·ªÅ nhau
            // M·ªói l·∫ßn qua level s·∫Ω tƒÉng th√™m m·ª©c ƒë·ªô tr·ªôn l√™n (currentLevel * 10) l·∫ßn
            for (let i = 0; i < (total / 2) + parseInt(currentLevel * 10); i++) {
                const r1 = Math.floor(Math.random() * ROWS), c1 = Math.floor(Math.random() * COLS);
                const r2 = Math.floor(Math.random() * ROWS), c2 = Math.floor(Math.random() * COLS);
                if (Math.abs(r1 - r2) + Math.abs(c1 - c2) > 2) {
                    [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
                }
            }
        }

        function render() {
            const tb = document.getElementById("board");
            tb.innerHTML = "";
            for (let r = 0; r < ROWS; r++) {
                const tr = document.createElement("tr");
                for (let c = 0; c < COLS; c++) {
                    const td = document.createElement("td");
                    td.style.width = "50px"; // ƒê·∫¢M B·∫¢O K√çCH TH∆Ø·ªöC C·ªê ƒê·ªäNH
                    td.style.height = "50px";

                    if (board[r][c] == 0) {
                        td.className = "empty";
                        // TH√äM CONTENT TRONG SU·ªêT ƒê·ªÇ GI·ªÆ K√çCH TH∆Ø·ªöC
                        td.innerHTML = "&nbsp;";
                    } else {
                        const img = document.createElement("img");
                        img.src = board[r][c];
                        img.style.width = "53px";
                        img.style.height = "53px";
                        img.style.objectFit = "contain";
                        td.appendChild(img);
                    }
                    if (selected.some(p => p.r === r && p.c === c)) td.classList.add("selected");
                    if (hintPair.some(p => p.r === r && p.c === c)) td.classList.add("hint");
                    td.onclick = () => onClick(r, c);
                    tr.appendChild(td);
                }
                tb.appendChild(tr);
            }
        }

        function getCell(r, c) {
            // Trong ph·∫°m vi b·∫£ng th·ª±c
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                return board[r][c];
            }
            // V√πng ·∫£o (ngo√†i b·∫£ng) - lu√¥n tr·∫£ v·ªÅ 0 (tr·ªëng)
            if (r >= MIN_R && r <= MAX_R && c >= MIN_C && c <= MAX_C) {
                return 0;
            }
            // Ngo√†i ph·∫°m vi cho ph√©p
            return null;
        }

        function isEmpty(r, c) { return getCell(r, c) === 0; }

        function clearHorizontal(a, b) {
            if (a.r !== b.r) return false;
            const row = a.r;
            const left = a.c < b.c ? a.c : b.c;
            const right = a.c < b.c ? b.c : a.c;
            for (let c = left + 1; c < right; c++) {
                const val = getCell(row, c);
                if (val === null || val !== 0) return false;
            }
            return true;
        }

        function clearVertical(a, b) {
            if (a.c !== b.c) return false;
            const col = a.c;
            const top = a.r < b.r ? a.r : b.r;
            const bottom = a.r < b.r ? b.r : a.r;
            for (let r = top + 1; r < bottom; r++) {
                const val = getCell(r, col);
                if (val === null || val !== 0) return false;
            }
            return true;
        }

        function findPath(start, end) {
            // BFS nodes: { r, c, dir, turns }
            // dir: 0=up,1=down,2=left,3=right, null = ch∆∞a di chuy·ªÉn
            // We'll allow positions outside b·∫£ng trong v√πng MIN_R..MAX_R, MIN_C..MAX_C (getCell x·ª≠ l√Ω)
            if (start.r === end.r && start.c === end.c) return null;

            // Quick direct checks (faster)
            if (start.r === end.r && clearHorizontal(start, end)) return [start, end];
            if (start.c === end.c && clearVertical(start, end)) return [start, end];

            const dirs = [
                [-1, 0], // up (0)
                [1, 0],  // down (1)
                [0, -1], // left (2)
                [0, 1],  // right (3)
            ];

            // visited map: key = `${r},${c},${dir}` -> minimal turns to reach
            const visited = new Map();
            const parent = new Map(); // parent key -> previous key (for reconstruct)
            const q = [];

            // push start as seed but we don't mark start cell with a direction; we will expand from start in all 4 directions
            for (let d = 0; d < 4; d++) {
                const nr = start.r + dirs[d][0];
                const nc = start.c + dirs[d][1];

                // stop immediately if out of allowed virtual region
                if (nr < MIN_R || nr > MAX_R || nc < MIN_C || nc > MAX_C) continue;

                // can step into if empty or it's the end cell
                const cellVal = getCell(nr, nc);
                if (cellVal === null) continue;
                if (cellVal !== 0 && !(nr === end.r && nc === end.c)) continue;

                const key = `${nr},${nc},${d}`;
                visited.set(key, 0); // 0 turns used so far (first segment started)
                parent.set(key, `${start.r},${start.c},-1`); // parent from start (dir -1)
                q.push({ r: nr, c: nc, dir: d, turns: 0 });
            }

            // BFS
            let foundKey = null;
            while (q.length) {
                const node = q.shift();
                const { r, c, dir, turns } = node;

                // if reached end cell
                if (r === end.r && c === end.c) {
                    foundKey = `${r},${c},${dir}`;
                    break;
                }

                // continue moving along same direction step by step (no new turn)
                // also can try turning to other directions (which increments turns)
                for (let d = 0; d < 4; d++) {
                    const nr = r + dirs[d][0];
                    const nc = c + dirs[d][1];

                    if (nr < MIN_R || nr > MAX_R || nc < MIN_C || nc > MAX_C) continue;
                    const cellVal = getCell(nr, nc);
                    if (cellVal === null) continue;
                    if (cellVal !== 0 && !(nr === end.r && nc === end.c)) continue;

                    // compute new turns count
                    const newTurns = (d === dir) ? turns : turns + 1;
                    if (newTurns > MAX_TURNS) continue;

                    const key = `${nr},${nc},${d}`;
                    if (!visited.has(key) || visited.get(key) > newTurns) {
                        visited.set(key, newTurns);
                        parent.set(key, `${r},${c},${dir}`);
                        q.push({ r: nr, c: nc, dir: d, turns: newTurns });
                    }
                }
            }

            if (!foundKey) return null;

            // reconstruct path from foundKey back to start
            const parts = [];
            let curKey = foundKey;
            while (curKey) {
                const [sr, sc, sdir] = curKey.split(',').map(x => parseInt(x, 10));
                // push cell coordinates
                parts.push({ r: sr, c: sc });
                const p = parent.get(curKey);
                if (!p) break;
                // parent for start was `${start.r},${start.c},-1`
                if (p === `${start.r},${start.c},-1`) {
                    parts.push({ r: start.r, c: start.c });
                    break;
                }
                curKey = p;
            }

            // parts is from end back to start; reverse
            parts.reverse();

            // normalize so first is start and last is end
            // ensure start included (should be)
            if (!(parts.length && parts[0].r === start.r && parts[0].c === start.c)) {
                parts.unshift({ r: start.r, c: start.c });
            }
            if (!(parts.length && parts[parts.length - 1].r === end.r && parts[parts.length - 1].c === end.c)) {
                parts.push({ r: end.r, c: end.c });
            }

            // compress to corner points (compressPath will remove collinear points)
            return compressPath(parts);
        }

        function canConnect(a, b) {
            if (a.r === b.r && a.c === b.c) return null;
            if (board[a.r][a.c] !== board[b.r][b.c]) return null;

            const tmpA = board[a.r][a.c];
            board[a.r][a.c] = 0;
            board[b.r][b.c] = 0;

            const path = findPath(a, b);

            board[a.r][a.c] = tmpA;
            board[b.r][b.c] = tmpA;
            return path;
        }

        function compressPath(path) { // Gi·ªØ start; lo·∫°i b·ªè c√°c ƒëi·ªÉm n·∫±m tr√™n c√πng 1 ƒëo·∫°n th·∫≥ng (gi·ªØ ƒëi·ªÉm cu·ªëi c·ªßa m·ªói ƒëo·∫°n)
            if (!path || path.length === 0) return [];
            const res = [path[0]];
            for (let i = 1; i < path.length; i++) {
                const cur = path[i];
                const prev = res[res.length - 1];
                const prev2 = res.length >= 2 ? res[res.length - 2] : null;

                // n·∫øu prev2, prev v√† cur c√πng h√†ng ho·∫∑c c√πng c·ªôt -> prev n·∫±m gi·ªØa 2 ƒëi·ªÉm th·∫≥ng, thay prev b·∫±ng cur
                if (prev2) {
                    const sameRow = (prev2.r === prev.r && prev.r === cur.r);
                    const sameCol = (prev2.c === prev.c && prev.c === cur.c);
                    if (sameRow || sameCol) {
                        // replace prev b·∫±ng cur ƒë·ªÉ co c·ª•m ƒëo·∫°n th·∫≥ng
                        res[res.length - 1] = cur;
                        continue;
                    }
                }
                res.push(cur);
            }
            return res;
        }

        function drawLine(path) {
            const svg = document.getElementById("lineLayer");
            svg.innerHTML = "";

            if (!path || path.length === 0) return;

            // L·∫•y elements
            const boardEl = document.getElementById("board");
            const boardContainer = document.getElementById("boardContainer");

            // L·∫•y bounding rects
            const boardRect = boardEl.getBoundingClientRect();
            const containerRect = boardContainer.getBoundingClientRect();

            // K√≠ch th∆∞·ªõc cell th·ª±c t·∫ø
            const firstTd = boardEl.querySelector("td");
            const cellW = firstTd ? firstTd.getBoundingClientRect().width : 50;
            const cellH = firstTd ? firstTd.getBoundingClientRect().height : 50;

            // Set SVG size b·∫±ng v·ªõi boardContainer
            svg.setAttribute("width", containerRect.width);
            svg.setAttribute("height", containerRect.height);
            svg.setAttribute("viewBox", `0 0 ${containerRect.width} ${containerRect.height}`);

            // T√≠nh offset t·ª´ boardContainer ƒë·∫øn board
            const offsetX = boardRect.left - containerRect.left;
            const offsetY = boardRect.top - containerRect.top;

            const compressed = compressPath(path);

            // T√≠nh points v·ªõi offset
            const pts = compressed.map(p => {
                const cx = offsetX + (p.c + 0.5) * cellW;
                const cy = offsetY + (p.r + 0.5) * cellH;
                return `${cx},${cy}`;
            }).join(" ");

            // T·∫°o polyline
            const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            polyline.setAttribute("points", pts);
            polyline.setAttribute("stroke", "yellow");
            polyline.setAttribute("stroke-width", "4");
            polyline.setAttribute("fill", "none");
            polyline.setAttribute("stroke-linejoin", "round");
            polyline.setAttribute("stroke-linecap", "round");
            polyline.style.filter = "drop-shadow(0 0 4px rgba(255,200,0,0.6))";

            svg.appendChild(polyline);
        }


        function clearLine() {
            document.getElementById("lineLayer").innerHTML = "";
        }

        function onClick(r, c) {
            if (board[r][c] == 0) return;

            clearHint();

            selected.push({ r, c });
            if (selected.length === 2) {
                const [a, b] = selected;
                const path = canConnect(a, b);
                if (path) {
                    playCorrectSound();
                    drawLine(path);
                    setTimeout(() => {
                        board[a.r][a.c] = 0;
                        board[b.r][b.c] = 0;
                        clearLine();
                        render();

                        if (checkLevelClear()) {
                            playLevelClearSound();
                            nextLevel();
                        } else {
                            // KI·ªÇM TRA C√ì ƒê∆Ø·ªúNG ƒêI H·ª¢P L·ªÜ KH√îNG
                            setTimeout(() => {
                                if (!hasValidMoves()) {
                                    showShuffleMessage();
                                    setTimeout(() => {
                                        shuffleRemaining();
                                    }, 1000);
                                }
                            }, 500);
                        }
                    }, 200);
                } else {
                    playWrongSound();
                    selected = [];
                    render();
                }
                selected = [];
            }
            render();
        }

        function checkLevelClear() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) return false;
                }
            }
            return true;
        }

        function nextLevel() {
            currentLevel++;
            updateLevel();
            // ·∫®n t·∫•t c·∫£ elements
            const container = document.getElementById("container");
            container.style.display = "none";

            createFireworks();

            const msg = document.createElement("div");
            msg.textContent = "üéâ Ch√∫c m·ª´ng b·∫°n ƒë√£ qua m√†n ti·∫øp theo ...";
            msg.style.position = "fixed";
            msg.style.top = "40%";
            msg.style.left = "50%";
            msg.style.transform = "translate(-50%, -50%)";
            msg.style.padding = "20px 40px";
            msg.style.fontSize = "20px";
            msg.style.color = "#fff";
            msg.style.background = "rgba(0,0,0,0.7)";
            msg.style.border = "2px solid #ffd700";
            msg.style.borderRadius = "10px";
            msg.style.zIndex = "1000";
            msg.style.textAlign = "center";
            msg.style.whiteSpace = "nowrap"; // Kh√¥ng cho xu·ªëng d√≤ng
            msg.style.display = "flex";
            msg.style.alignItems = "center";
            msg.style.justifyContent = "center";
            msg.style.minWidth = "auto"; // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh ƒë·ªô r·ªông
            msg.style.width = "auto";
            document.body.appendChild(msg);

            setTimeout(() => {
                document.body.removeChild(msg);
                container.style.display = "flex"; // Hi·ªÉn th·ªã l·∫°i container
                initBoard();
                render();
            }, 3000);
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function createAudioContext() {
            return new (window.AudioContext || window.webkitAudioContext)();
        }

        function playCorrectSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh vui v·∫ª cho ƒë√∫ng: C4 -> E4 -> G4
                oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime); // C4
                oscillator.frequency.setValueAtTime(329.63, audioContext.currentTime + 0.1); // E4
                oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime + 0.2); // G4

                oscillator.type = 'triangle';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function playWrongSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh bu·ªìn cho sai: G4 -> D4 -> C4
                oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime); // G4
                oscillator.frequency.setValueAtTime(293.66, audioContext.currentTime + 0.1); // D4
                oscillator.frequency.setValueAtTime(261.63, audioContext.currentTime + 0.2); // C4

                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function playLevelClearSound() {
            if (!soundEnabled) return;
            try {
                const audioContext = createAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // √Çm thanh chi·∫øn th·∫Øng: C5 -> E5 -> G5 -> C6
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.15); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.3); // G5
                oscillator.frequency.setValueAtTime(1046.50, audioContext.currentTime + 0.45); // C6

                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.6);
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function findHint() {
            const cells = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) {
                        cells.push({ r, c, value: board[r][c] });
                    }
                }
            }

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const a = cells[i];
                    const b = cells[j];
                    if (a.value === b.value && canConnect(a, b)) {
                        return [a, b];
                    }
                }
            }
            return null;
        }

        function showHint() {
            clearHint();

            if (!hasValidMoves()) {
                alert("Kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá! S·∫Ω t·ª± ƒë·ªông s·∫Øp x·∫øp l·∫°i...");
                shuffleRemaining();
                return;
            }

            hintPair = findHint();

            if (hintPair) {
                render();
                setTimeout(clearHint, 3000);
            }
        }

        function clearHint() {
            hintPair = [];
            const hintCells = document.querySelectorAll("td.hint");
            hintCells.forEach(cell => cell.classList.remove("hint"));
        }

        function newGame() {
            // Reset game state
            selected = [];
            hintPair = [];
            clearHint();
            clearLine();

            // T·∫°o b√†n ch∆°i m·ªõi
            initBoard();
            render();
        }

        function updateLevel() {
            document.getElementById('levelNumber').textContent = currentLevel;
        }

        function changeSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? "üîä √Çm thanh" : "üîá T·∫Øt √¢m thanh";
        }

        document.getElementById('hintBtn').addEventListener('click', showHint);
        document.getElementById('refreshBtn').addEventListener('click', newGame);
        document.getElementById('soundBtn').addEventListener('click', changeSound);

        initBoard();
        render();

        window.addEventListener("orientationchange", () => {
            if (window.orientation === 90 || window.orientation === -90) {
                // N·∫±m ngang
                document.getElementById("container").style.display = "flex";
                document.body.removeAttribute("data-portrait");
            } else {
                // ƒê·ª©ng d·ªçc
                document.getElementById("container").style.display = "none";
                document.body.setAttribute("data-portrait", "true");
            }
        });

        function hideAddressBar() {
            if (window.innerHeight < window.outerHeight) {
                setTimeout(() => {
                    window.scrollTo(0, 1);
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                    }, 100);
                }, 500);
            }
        }

        function hasValidMoves() {
            const cells = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) {
                        cells.push({ r, c, value: board[r][c] });
                    }
                }
            }

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const a = cells[i];
                    const b = cells[j];
                    if (a.value === b.value && canConnect(a, b)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function shuffleRemaining() {
            // L·∫•y t·∫•t c·∫£ h√¨nh c√≤n l·∫°i
            let remaining = [];
            let positions = [];

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] !== 0) {
                        remaining.push(board[r][c]);
                        positions.push({ r, c });
                        board[r][c] = 0; // X√≥a t·∫°m th·ªùi
                    }
                }
            }

            // Shuffle m·∫£ng h√¨nh
            for (let i = remaining.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
            }

            // ƒê·∫∑t l·∫°i h√¨nh v√†o v·ªã tr√≠
            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];
                board[pos.r][pos.c] = remaining[i];
            }

            render();
        }

        function showShuffleMessage() {
            const msg = document.createElement("div");
            msg.textContent = "üîÑ Kh√¥ng c√≤n ƒë∆∞·ªùng ƒëi! ƒêang s·∫Øp x·∫øp l·∫°i...";
            msg.style.position = "fixed";
            msg.style.top = "50%";
            msg.style.left = "50%";
            msg.style.transform = "translate(-50%, -50%)";
            msg.style.padding = "15px 30px";
            msg.style.fontSize = "18px";
            msg.style.color = "#fff";
            msg.style.background = "rgba(255, 165, 0, 0.9)";
            msg.style.border = "2px solid #ff8c00";
            msg.style.borderRadius = "10px";
            msg.style.zIndex = "1000";
            document.body.appendChild(msg);

            setTimeout(() => {
                if (document.body.contains(msg)) {
                    document.body.removeChild(msg);
                }
            }, 1500);
        }

        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

    </script>
</body>

</html>